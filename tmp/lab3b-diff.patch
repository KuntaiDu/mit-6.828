diff --git a/kern/env.c b/kern/env.c
index db2fda9..1a2462e 100644
--- a/kern/env.c
+++ b/kern/env.c
@@ -116,6 +116,13 @@ env_init(void)
 {
 	// Set up envs array
 	// LAB 3: Your code here.
+	env_free_list = NULL;
+	for(int i = NENV - 1; i >= 0; i --) {
+		envs[i].env_id = 0;
+		envs[i].env_status = ENV_FREE;
+		envs[i].env_link = env_free_list;
+		env_free_list = envs + i;
+	}
 
 	// Per-CPU part of the initialization
 	env_init_percpu();
@@ -150,7 +157,8 @@ env_init_percpu(void)
 // of the environment's virtual address space.
 //
 // Returns 0 on success, < 0 on error.  Errors include:
-//	-E_NO_MEM if page directory or table could not be allocated.
+//	-E_NO_MEM if page directory or table could nos[i].env_link = env_free_link;
+//	env_free_link = envs + i;ted.
 //
 static int
 env_setup_vm(struct Env *e)
@@ -179,6 +187,12 @@ env_setup_vm(struct Env *e)
 	//    - The functions in kern/pmap.h are handy.
 
 	// LAB 3: Your code here.
+	// Store this page
+	e->env_pgdir = page2kva(p);
+	// Copy this page
+	memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
+	// Referred to this page.
+	p->pp_ref ++;
 
 	// UVPT maps the env's own page table read-only.
 	// Permissions: kernel R, user R
@@ -267,6 +281,21 @@ region_alloc(struct Env *e, void *va, size_t len)
 	//   'va' and 'len' values that are not page-aligned.
 	//   You should round va down, and round (va + len) up.
 	//   (Watch out for corner-cases!)
+	
+	void *st = ROUNDDOWN(va, PGSIZE), *ed = ROUNDUP(va + len, PGSIZE);
+	struct PageInfo *p = NULL;
+	int ret = 0;
+
+
+	// Allocate pages
+	for(; st < ed; st += PGSIZE) {
+		p = page_alloc(ALLOC_ZERO);
+		if (p == NULL)
+			panic("[E] region_alloc: %e", -E_NO_MEM);
+		ret = page_insert(e->env_pgdir, p, st, PTE_U | PTE_W);
+		if (ret != 0)
+			panic("[E] region_alloc: %e", ret);
+	}
 }
 
 //
@@ -323,11 +352,33 @@ load_icode(struct Env *e, uint8_t *binary)
 	//  What?  (See env_run() and env_pop_tf() below.)
 
 	// LAB 3: Your code here.
+	struct Elf *elf = (struct Elf*) binary;
+
+	// Sanity Check
+	if (elf->e_magic != ELF_MAGIC)
+		panic("[E] load_icode: not an excecutable ELF file.");
+
+	struct Proghdr *ph = (struct Proghdr*) (binary + elf->e_phoff);
+	struct Proghdr *eph = ph + elf->e_phnum;
+	// To the pagedir of user env.
+	lcr3(PADDR(e->env_pgdir));
+
+	for(; ph < eph; ph ++) {
+		if (ph->p_type == ELF_PROG_LOAD) {
+			region_alloc(e, (void *) ph->p_va, ph->p_memsz);
+			memset((void *)ph->p_va, 0, ph->p_memsz);
+			memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
+		}
+	}
+
+	// To kernel env
+	lcr3(PADDR(kern_pgdir));
+	e->env_tf.tf_eip = elf->e_entry;
+
 
 	// Now map one page for the program's initial stack
 	// at virtual address USTACKTOP - PGSIZE.
-
-	// LAB 3: Your code here.
+	region_alloc(e, (void *) (USTACKTOP - PGSIZE), PGSIZE);
 }
 
 //
@@ -341,6 +392,17 @@ void
 env_create(uint8_t *binary, enum EnvType type)
 {
 	// LAB 3: Your code here.
+	struct Env *e = NULL;
+	int ret;
+	ret = env_alloc(&e, 0);
+
+	// Sanity check
+	if (ret < 0 ) {
+		panic("[E] env_create: %e", ret);
+	}
+
+	load_icode(e, binary);
+	e->env_type = type;
 }
 
 //
@@ -457,7 +519,14 @@ env_run(struct Env *e)
 	//	e->env_tf to sensible values.
 
 	// LAB 3: Your code here.
+	if (curenv && curenv->env_status == ENV_RUNNING) {
+		curenv->env_status = ENV_RUNNABLE;
+	}
 
-	panic("env_run not yet implemented");
-}
+	curenv = e;
+	curenv->env_status = ENV_RUNNING;
+	curenv->env_runs ++;
+	lcr3(PADDR(e->env_pgdir));
+	env_pop_tf(&curenv->env_tf);
 
+}
diff --git a/kern/init.c b/kern/init.c
index 3d4122c..e0ead82 100644
--- a/kern/init.c
+++ b/kern/init.c
@@ -26,6 +26,11 @@ i386_init(void)
 	// Can't call cprintf until after we do this!
 	cons_init();
 
+	// To print a color!
+	char esc_char = 0x1b;
+	char color_string[10] = "[91m";
+	cprintf("%c%s", esc_char, color_string);
+
 	cprintf("6828 decimal is %o octal!\n", 6828);
 
 	// Lab 2 memory management initialization functions
diff --git a/kern/kdebug.c b/kern/kdebug.c
index f4ee8ee..e79edf3 100644
--- a/kern/kdebug.c
+++ b/kern/kdebug.c
@@ -198,12 +198,22 @@ debuginfo_eip(uintptr_t addr, struct Eipdebuginfo *info)
 	// Search within [lline, rline] for the line number stab.
 	// If found, set info->eip_line to the right line number.
 	// If not found, return -1.
-	//
-	// Hint:
-	//	There's a particular stabs type used for line numbers.
-	//	Look at the STABS documentation and <inc/stab.h> to find
-	//	which one.
-	// Your code here.
+	// (N_SLINE)
+	lline = lfun;
+	rline = rfun;
+	stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+
+	if (lfun <= rfun) {
+		// Found. The lineno lies in the description field of stabs
+		info->eip_line = stabs[lline].n_desc;
+
+	}
+	else {
+		// Not found. Just return -1
+		// Set info->eip_line to stabs[lline].n_desc for robustness.
+		info->eip_line = stabs[lline].n_desc;
+		return -1;
+	}
 
 
 	// Search backwards from the line number for the relevant filename
diff --git a/kern/monitor.c b/kern/monitor.c
index 4e00796..a24f349 100644
--- a/kern/monitor.c
+++ b/kern/monitor.c
@@ -25,6 +25,10 @@ struct Command {
 static struct Command commands[] = {
 	{ "help", "Display this list of commands", mon_help },
 	{ "kerninfo", "Display information about the kernel", mon_kerninfo },
+	{ "backtrace", "Display backtrace information about the stack", mon_backtrace },
+	{ "showmappings", "Display the page mappings in range [begin_address, end_address)",
+	  mon_showmappings },
+	{ "continue", "Continue from the last breakpoint.", mon_continue }
 };
 
 /***** Implementations of basic kernel monitor commands *****/
@@ -58,10 +62,111 @@ mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
 int
 mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 {
-	// Your code here.
+	
+	// First get the position of ebp
+	typedef unsigned int *ptr;
+	ptr ebp = (ptr) read_ebp();
+	cprintf("Stack backtrace:\n");
+
+	// Use this variable to fetch debuginfo
+	struct Eipdebuginfo debug_info;
+
+	// Use this variable to store eip
+	ptr eip = NULL;
+
+	while (ebp != NULL) {
+
+		// Get eip
+		eip = (ptr)*(ebp + 1);
+
+		// Print ebp and eip
+		cprintf("ebp %08x ", ebp);
+		cprintf("eip %08x ", eip);
+
+		// Print args
+		cprintf("args");
+		for(int i = 2; i <= 6; i ++) {
+			cprintf(" %08x", *(ebp + i));
+		}
+		cprintf("\n");
+
+		// Get debug_info and print it
+		debuginfo_eip((uintptr_t) eip, &debug_info);
+
+		// Note that we need to make debug_info.eip_fn_name shorter
+		cprintf("\t%s:%d: %.*s+%d\n",
+				debug_info.eip_file,
+				debug_info.eip_line,
+				debug_info.eip_fn_namelen,
+				debug_info.eip_fn_name,
+				(uintptr_t) eip - debug_info.eip_fn_addr);
+
+		// Goto upper-level function
+		ebp = (ptr) *ebp;
+
+	}
+
 	return 0;
 }
 
+int mon_showmappings(int argc, char **argv, struct Trapframe *tf) {
+	// Extern variables
+	extern pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
+	extern pde_t *kern_pgdir;
+
+	if (argc != 3) {
+		cprintf("Usage: showmappings: begin_address end_address\n");
+		return 0;
+	}
+
+	long begin = strtol(argv[1], NULL, 16);
+	long end = strtol(argv[2], NULL, 16);
+
+	// Sanity check
+	assert(begin < end);
+	assert(end <= 0xffffffff);
+	assert(begin == ROUNDUP(begin, PGSIZE));
+	assert(end == ROUNDUP(end, PGSIZE));
+
+	for (; begin < end; begin += PGSIZE) {
+		cprintf("%08x--%08x: ", begin, begin + PGSIZE);
+		pte_t *pg_tbl_entry = pgdir_walk(kern_pgdir, (void *)begin, 0);
+		if (pg_tbl_entry == NULL) {
+			cprintf("Not mapped\n");
+			continue;
+		}
+		cprintf("page %08x ", PTE_ADDR(*pg_tbl_entry));
+		cprintf("PTE_P: %x, PTE_W: %x, PTE_U: %x\n",
+				*pg_tbl_entry & PTE_P,
+				*pg_tbl_entry & PTE_W,
+				*pg_tbl_entry & PTE_U);
+	}
+
+	return 0;
+}
+
+int mon_continue(int argc, char **argv, struct Trapframe *tf) {
+	// Sanity Check
+	if (argc != 1) {
+		cprintf("[W]: Do not need any argument.\n");
+		return 0;
+	}
+	// No breakpoint exception?
+	if (tf->tf_trapno != T_BRKPT) {
+		cprintf("[E]: Cannot continue: no breakpoint exception.\n");
+		return 0;
+	}
+	// Set the Trap Flags
+	extern struct Env *curenv;
+	if (curenv == NULL) {
+		// No process running
+		cprintf("[E]: Cannot continue: no process running.\n");
+		return 0;
+	}
+	// Return to trap_dispatch().
+	return -1;
+}
+
 
 
 /***** Kernel monitor command interpreter *****/
diff --git a/kern/monitor.h b/kern/monitor.h
index 0aa0f26..52c2cfa 100644
--- a/kern/monitor.h
+++ b/kern/monitor.h
@@ -15,5 +15,7 @@ void monitor(struct Trapframe *tf);
 int mon_help(int argc, char **argv, struct Trapframe *tf);
 int mon_kerninfo(int argc, char **argv, struct Trapframe *tf);
 int mon_backtrace(int argc, char **argv, struct Trapframe *tf);
+int mon_showmappings(int argc, char **argv, struct Trapframe *tf);
+int mon_continue(int argc, char **argv, struct Trapframe *tf);
 
 #endif	// !JOS_KERN_MONITOR_H
diff --git a/kern/pmap.c b/kern/pmap.c
index 1716265..d14985e 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -101,10 +101,13 @@ boot_alloc(uint32_t n)
 	// Allocate a chunk large enough to hold 'n' bytes, then update
 	// nextfree.  Make sure nextfree is kept aligned
 	// to a multiple of PGSIZE.
-	//
-	// LAB 2: Your code here.
-
-	return NULL;
+	result = nextfree;
+	nextfree = ROUNDUP(nextfree + n, PGSIZE);	// Align
+	if (PADDR(nextfree) > npages * PGSIZE) {	// Sanity check
+		nextfree = result;	// Restore nextfree
+		panic("out of memory\n");
+	}
+	return result;
 }
 
 // Set up a two-level page table:
@@ -125,9 +128,6 @@ mem_init(void)
 	// Find out how much memory the machine has (npages & npages_basemem).
 	i386_detect_memory();
 
-	// Remove this line when you're ready to test this function.
-	panic("mem_init: This function is not finished\n");
-
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
 	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
@@ -149,11 +149,15 @@ mem_init(void)
 	// array.  'npages' is the number of physical pages in memory.  Use memset
 	// to initialize all fields of each struct PageInfo to 0.
 	// Your code goes here:
-
+	pages = (struct PageInfo*) boot_alloc(sizeof(struct PageInfo) * npages);
+	memset(pages, 0, sizeof(struct PageInfo) * npages);
+	page_free_list = NULL;
 
 	//////////////////////////////////////////////////////////////////////
 	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
 	// LAB 3: Your code here.
+	envs = (struct Env*) boot_alloc(sizeof(struct Env) * NENV);
+	memset(envs, 0, sizeof(struct Env) * NENV);
 
 	//////////////////////////////////////////////////////////////////////
 	// Now that we've allocated the initial kernel data structures, we set
@@ -173,10 +177,15 @@ mem_init(void)
 	//////////////////////////////////////////////////////////////////////
 	// Map 'pages' read-only by the user at linear address UPAGES
 	// Permissions:
-	//    - the new image at UPAGES -- kernel R, user R
+	//    - the nresultimage at UPAGES -- kernel R, user R
 	//      (ie. perm = PTE_U | PTE_P)
 	//    - pages itself -- kernel RW, user NONE
 	// Your code goes here:
+	boot_map_region(kern_pgdir, 
+			UPAGES, 
+			PTSIZE, 
+			PADDR((void *)(pages)),  
+			PTE_U | PTE_P);
 
 	//////////////////////////////////////////////////////////////////////
 	// Map the 'envs' array read-only by the user at linear address UENVS
@@ -185,6 +194,11 @@ mem_init(void)
 	//    - the new image at UENVS  -- kernel R, user R
 	//    - envs itself -- kernel RW, user NONE
 	// LAB 3: Your code here.
+	boot_map_region(kern_pgdir,
+			UENVS,
+			PTSIZE,
+			PADDR((void *) envs),
+			PTE_U | PTE_P);
 
 	//////////////////////////////////////////////////////////////////////
 	// Use the physical memory that 'bootstack' refers to as the kernel
@@ -197,6 +211,12 @@ mem_init(void)
 	//       overwrite memory.  Known as a "guard page".
 	//     Permissions: kernel RW, user NONE
 	// Your code goes here:
+	boot_map_region(kern_pgdir,
+			KSTACKTOP - KSTKSIZE,
+			KSTKSIZE,
+			PADDR(bootstack),
+			PTE_W | PTE_P);
+	// Don't need to care about [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)
 
 	//////////////////////////////////////////////////////////////////////
 	// Map all of physical memory at KERNBASE.
@@ -206,6 +226,11 @@ mem_init(void)
 	// we just set up the mapping anyway.
 	// Permissions: kernel RW, user NONE
 	// Your code goes here:
+	boot_map_region(kern_pgdir,
+			KERNBASE,
+			0xffffffff -  KERNBASE + 1,
+			(physaddr_t)(NULL),
+			PTE_W | PTE_P);
 
 	// Check that the initial page directory has been set up correctly.
 	check_kern_pgdir();
@@ -259,13 +284,28 @@ page_init(void)
 	//  4) Then extended memory [EXTPHYSMEM, ...).
 	//     Some of it is in use, some is free. Where is the kernel
 	//     in physical memory?  Which pages are already in use for
-	//     page tables and other data structures?
+	//     page tables and other data structure?
 	//
 	// Change the code to reflect this.
 	// NB: DO NOT actually touch the physical memory corresponding to
 	// free pages!
+	
+	// Find out how much pages are allocated in extended memory.
+	size_t npages_alloc_exmem = PGNUM(PADDR(boot_alloc(0)));
+	// Find out the page number of IOPHYSMEM and EXTPHYSMEM
+	size_t npages_io = PGNUM(IOPHYSMEM), npages_ex = PGNUM(IOPHYSMEM);
 	size_t i;
 	for (i = 0; i < npages; i++) {
+		if (i == 0) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+			continue;
+		}
+		if (i >= npages_io && i < npages_alloc_exmem) {
+			pages[i].pp_ref = 1;
+			pages[i].pp_link = NULL;
+			continue;
+		}
 		pages[i].pp_ref = 0;
 		pages[i].pp_link = page_free_list;
 		page_free_list = &pages[i];
@@ -287,8 +327,17 @@ page_init(void)
 struct PageInfo *
 page_alloc(int alloc_flags)
 {
-	// Fill this function in
-	return 0;
+	if (page_free_list == NULL)	//Sanity check
+		return NULL;
+
+	struct PageInfo *page = page_free_list;	// Get first free page
+	page_free_list = page_free_list->pp_link;
+	assert(page->pp_ref == 0);	// Sanity check
+	page->pp_link = NULL;
+	if (alloc_flags & ALLOC_ZERO) {	// Initialize
+		memset(page2kva(page), 0, PGSIZE);
+	}
+	return page;
 }
 
 //
@@ -298,9 +347,13 @@ page_alloc(int alloc_flags)
 void
 page_free(struct PageInfo *pp)
 {
-	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
 	// pp->pp_link is not NULL.
+	assert(pp->pp_link == NULL);	// Sanity check
+	assert(pp->pp_ref == 0);	// Sanity check
+
+	pp->pp_link = page_free_list;
+	page_free_list = pp;
 }
 
 //
@@ -339,8 +392,28 @@ page_decref(struct PageInfo* pp)
 pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
-	// Fill this function in
-	return NULL;
+	// Fetch pde
+	pde_t *dir_entry = pgdir + PDX(va);
+
+	if (!(*dir_entry & PTE_P)) {	// Not present
+		if (create) {	// Create this entry.
+			struct PageInfo *pg = page_alloc(1);
+			if (pg == NULL) {
+				return NULL;
+			}
+			pg->pp_ref ++;
+			pg->pp_link = NULL;	// Allocated
+			*dir_entry = (page2pa(pg) | PTE_P | PTE_W | PTE_U);
+		}
+		else {
+			return NULL;
+		}
+	}
+
+	// Fetch pte
+	pte_t *pg_tbl_entry = (pte_t *)(KADDR(PTE_ADDR(*dir_entry))) + PTX(va);
+
+	return pg_tbl_entry;
 }
 
 //
@@ -357,7 +430,13 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
-	// Fill this function in
+	// multiple PTE should be allocated.
+	for (; size; size -= PGSIZE, va += PGSIZE, pa += PGSIZE) {
+		// Fetch corresponding page table entry
+		pte_t *pg_tbl_entry = pgdir_walk(pgdir, (void *)va, 1);
+		// Fill in the content
+		*pg_tbl_entry = (pa | perm | PTE_P);
+	}
 }
 
 //
@@ -388,7 +467,23 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
-	// Fill this function in
+	// Create a page
+	pte_t *pg_tbl_entry = pgdir_walk(pgdir, va, 1);
+	if (pg_tbl_entry == NULL)
+		return -E_NO_MEM;
+
+	// This page will be used/
+	pp->pp_ref ++;
+
+	if ((*pg_tbl_entry) & PTE_P) {
+		page_remove(pgdir, va);
+		tlb_invalidate(pgdir, va);
+	}
+
+	// Set the value of page table entry
+	pgdir[PDX(va)] |= perm;
+	*pg_tbl_entry = (page2pa(pp) | perm | PTE_P);
+
 	return 0;
 }
 
@@ -406,8 +501,23 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
-	// Fill this function in
-	return NULL;
+	// Fetch page table entry
+	pte_t *pg_tbl_entry = pgdir_walk(pgdir, va, 0);
+	
+	// Sanity check
+	if (pg_tbl_entry == NULL) {
+		return NULL;
+	}
+	if (!((*pg_tbl_entry) & (PTE_P))) {
+		return NULL;
+	}
+
+	// Insert dir_entry to pte_store
+	if (pte_store != NULL) {
+		*pte_store = pg_tbl_entry;
+	}
+
+	return pa2page(PTE_ADDR(*pg_tbl_entry));
 }
 
 //
@@ -428,7 +538,23 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 void
 page_remove(pde_t *pgdir, void *va)
 {
-	// Fill this function in
+	// Find page and page table entry
+	pte_t *pg_tbl_entry = NULL;
+	struct PageInfo *page = page_lookup(pgdir, va, &pg_tbl_entry);
+	
+	// If no physical page?
+	if (page == NULL) {
+		return;	// Do nothing
+	}
+
+	// Decrease ppref
+	page_decref(page);
+
+	// invalidate TLB
+	tlb_invalidate(pgdir, va);
+
+	// Clear page table entry
+	*pg_tbl_entry = 0;
 }
 
 //
@@ -467,6 +593,14 @@ int
 user_mem_check(struct Env *env, const void *va, size_t len, int perm)
 {
 	// LAB 3: Your code here.
+	uintptr_t ed = ROUNDUP((uintptr_t) va + len, PGSIZE);
+	for (uintptr_t it = (uintptr_t) va; it < ed; it = ROUNDUP(it + 1, PGSIZE)) {
+    		pte_t *pg_tbl_entry = pgdir_walk(env->env_pgdir, (void *) it, false);
+    		if (pg_tbl_entry == NULL || (((*pg_tbl_entry) & perm) != perm) || it >= ULIM) {
+        		user_mem_check_addr = it;
+        		return -E_FAULT;
+    		}
+	}
 
 	return 0;
 }
diff --git a/kern/syscall.c b/kern/syscall.c
index 414d489..6a76510 100644
--- a/kern/syscall.c
+++ b/kern/syscall.c
@@ -21,7 +21,7 @@ sys_cputs(const char *s, size_t len)
 	// Destroy the environment if not.
 
 	// LAB 3: Your code here.
-
+	user_mem_assert(curenv, s, len, PTE_U | PTE_W);
 	// Print the string supplied by the user.
 	cprintf("%.*s", len, s);
 }
@@ -69,10 +69,17 @@ syscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4,
 	// Call the function corresponding to the 'syscallno' parameter.
 	// Return any appropriate return value.
 	// LAB 3: Your code here.
-
-	panic("syscall not implemented");
-
+	
 	switch (syscallno) {
+	case SYS_cputs:
+		sys_cputs((const char *)a1, (size_t)a2);
+		return 0;
+	case SYS_cgetc:
+		return sys_cgetc();
+	case SYS_env_destroy:
+		return sys_env_destroy((envid_t)a1);
+	case SYS_getenvid:
+		return sys_getenvid();
 	default:
 		return -E_INVAL;
 	}
diff --git a/kern/trap.c b/kern/trap.c
index e27b556..8fda037 100644
--- a/kern/trap.c
+++ b/kern/trap.c
@@ -63,10 +63,59 @@ void
 trap_init(void)
 {
 	extern struct Segdesc gdt[];
-
+	
 	// LAB 3: Your code here.
-
-	// Per-CPU setup 
+	extern void th0();
+	extern void th1();
+	extern void th2();
+	extern void th3();
+	extern void th4();
+	extern void th5();
+	extern void th6();
+	extern void th7();
+	extern void th8();
+	extern void th10();
+	extern void th11();
+	extern void th12();
+	extern void th13();
+	extern void th14();
+	extern void th16();
+	extern void th17();
+	extern void th18();
+	extern void th19();
+	extern void th32();
+	extern void th33();
+	extern void th36();
+	extern void th39();
+	extern void th46();
+	extern void system_call();
+	extern void th51();
+	SETGATE(idt[T_DIVIDE], 0, GD_KT, th0, 0);
+	SETGATE(idt[T_DEBUG], 0, GD_KT, th1, 0);
+	SETGATE(idt[T_NMI], 0, GD_KT, th2, 0);
+	SETGATE(idt[T_BRKPT], 0, GD_KT, th3, 3);
+	SETGATE(idt[T_OFLOW], 0, GD_KT, th4, 0);
+	SETGATE(idt[T_BOUND], 0, GD_KT, th5, 0);
+	SETGATE(idt[T_ILLOP], 0, GD_KT, th6, 0);
+	SETGATE(idt[T_DEVICE], 0, GD_KT, th7, 0);
+	SETGATE(idt[T_DBLFLT], 0, GD_KT, th8, 0);
+	SETGATE(idt[T_TSS], 0, GD_KT, th10, 0);
+	SETGATE(idt[T_SEGNP], 0, GD_KT, th11, 0);
+	SETGATE(idt[T_STACK], 0, GD_KT, th12, 0);
+	SETGATE(idt[T_GPFLT], 0, GD_KT, th13, 0);
+	SETGATE(idt[T_PGFLT], 0, GD_KT, th14, 0);
+	SETGATE(idt[T_FPERR], 0, GD_KT, th16, 0);
+	SETGATE(idt[T_ALIGN], 0, GD_KT, th17, 0);
+	SETGATE(idt[T_MCHK], 0, GD_KT, th18, 0);
+	SETGATE(idt[T_SIMDERR], 0, GD_KT, th19, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER], 0, GD_KT, th32, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_KBD], 0, GD_KT, th33, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL], 0, GD_KT, th36, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], 0, GD_KT, th39, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_IDE], 0, GD_KT, th46, 0);
+	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR], 0, GD_KT, th51, 0);
+	SETGATE(idt[T_SYSCALL], 0, GD_KT, system_call, 3);
+	
 	trap_init_percpu();
 }
 
@@ -143,7 +192,33 @@ static void
 trap_dispatch(struct Trapframe *tf)
 {
 	// Handle processor exceptions.
-	// LAB 3: Your code here.
+	// LAB 3: Your code here
+	switch(tf->tf_trapno) {
+		case T_PGFLT:
+			page_fault_handler(tf);
+			return;
+		case T_BRKPT:
+			cprintf("[W]: Breakpoint exception received. Jump to kernel.\n");
+			monitor(tf);
+
+			curenv->env_tf.tf_eflags |= FL_TF;
+			cprintf("Continue running from the last breakpoint...\n");
+			return;
+		case T_SYSCALL:
+			tf->tf_regs.reg_eax = syscall(
+					tf->tf_regs.reg_eax,
+					tf->tf_regs.reg_edx,
+					tf->tf_regs.reg_ecx,
+					tf->tf_regs.reg_ebx,
+					tf->tf_regs.reg_edi,
+					tf->tf_regs.reg_esi
+				     );
+			if (tf->tf_regs.reg_eax < 0) {
+				panic("[E] trap_dispatch: %e", tf->tf_regs.reg_eax);
+			}
+			
+			return;
+	}
 
 	// Unexpected trap: The user process or the kernel has a bug.
 	print_trapframe(tf);
@@ -168,6 +243,7 @@ trap(struct Trapframe *tf)
 	assert(!(read_eflags() & FL_IF));
 
 	cprintf("Incoming TRAP frame at %p\n", tf);
+	// cprintf("TRAPNO is %d\n", tf->tf_trapno);
 
 	if ((tf->tf_cs & 3) == 3) {
 		// Trapped from user mode.
@@ -204,7 +280,9 @@ page_fault_handler(struct Trapframe *tf)
 
 	// Handle kernel-mode page faults.
 
-	// LAB 3: Your code here.
+	if ((tf->tf_cs & 3) == 0) {
+		panic("[E] page_fault_handler: page fault in kernel");
+	}
 
 	// We've already handled kernel-mode exceptions, so if we get here,
 	// the page fault happened in user mode.
diff --git a/kern/trapentry.S b/kern/trapentry.S
index 22fc640..e176f4f 100644
--- a/kern/trapentry.S
+++ b/kern/trapentry.S
@@ -46,10 +46,51 @@
 /*
  * Lab 3: Your code here for generating entry points for the different traps.
  */
-
-
+/* th for trap handler */
+TRAPHANDLER_NOEC(th0, T_DIVIDE)
+TRAPHANDLER_NOEC(th1, T_DEBUG)
+TRAPHANDLER_NOEC(th2, T_NMI)
+TRAPHANDLER_NOEC(th3, T_BRKPT)
+TRAPHANDLER_NOEC(th4, T_OFLOW)
+TRAPHANDLER_NOEC(th5, T_BOUND)
+TRAPHANDLER_NOEC(th6, T_ILLOP)
+TRAPHANDLER_NOEC(th7, T_DEVICE)
+TRAPHANDLER(th8, T_DBLFLT)
+/* th9: CoProcessor Segment Overrun reserved */
+TRAPHANDLER(th10, T_TSS)
+TRAPHANDLER(th11, T_SEGNP)
+TRAPHANDLER(th12, T_STACK)
+TRAPHANDLER(th13, T_GPFLT)
+TRAPHANDLER(th14, T_PGFLT)
+/* th15: reserved */
+TRAPHANDLER(th16, T_FPERR)
+TRAPHANDLER(th17, T_ALIGN)
+TRAPHANDLER(th18, T_MCHK)
+TRAPHANDLER(th19, T_SIMDERR)
+/* for IRQ */
+TRAPHANDLER_NOEC(th32, IRQ_OFFSET + IRQ_TIMER)
+TRAPHANDLER_NOEC(th33, IRQ_OFFSET + IRQ_KBD)
+TRAPHANDLER_NOEC(th36, IRQ_OFFSET + IRQ_SERIAL)
+TRAPHANDLER_NOEC(th39, IRQ_OFFSET + IRQ_SPURIOUS)
+TRAPHANDLER_NOEC(th46, IRQ_OFFSET + IRQ_IDE)
+TRAPHANDLER_NOEC(th51, IRQ_OFFSET + IRQ_ERROR)
+/* SYSCALL */
+TRAPHANDLER_NOEC(system_call, T_SYSCALL)
 
 /*
  * Lab 3: Your code here for _alltraps
  */
+_alltraps:
+	pushl %ds
+	pushl %es
+	pushal
+
+	movw $(GD_KD), %eax
+	movw %ax, %ds
+	movw %ax, %es
+
+	pushl %esp
+
+	call trap
+
 
diff --git a/lib/libmain.c b/lib/libmain.c
index 8a14b29..67fd1b3 100644
--- a/lib/libmain.c
+++ b/lib/libmain.c
@@ -12,8 +12,8 @@ void
 libmain(int argc, char **argv)
 {
 	// set thisenv to point at our Env structure in envs[].
-	// LAB 3: Your code here.
-	thisenv = 0;
+	// LAB 3: Your code here
+	thisenv = envs + ENVX(sys_getenvid());
 
 	// save the name of the program so that panic() can use it
 	if (argc > 0)
diff --git a/lib/printfmt.c b/lib/printfmt.c
index 28e01c9..1d3a5fa 100644
--- a/lib/printfmt.c
+++ b/lib/printfmt.c
@@ -206,10 +206,13 @@ vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
 		// (unsigned) octal
 		case 'o':
 			// Replace this with your code.
-			putch('X', putdat);
-			putch('X', putdat);
-			putch('X', putdat);
-			break;
+			num = getint(&ap, lflag);
+			if ((long long) num < 0) {
+				putch('-', putdat);
+				num = -(long long) num;
+			}
+			base = 8;
+			goto number;
 
 		// pointer
 		case 'p':
